#!/bin/bash
set -euo pipefail
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"


# References:
#   - Let's Encrypt staging environment guidance: https://letsencrypt.org/docs/staging-environment/
#   - Certbot user guide: https://eff-certbot.readthedocs.io/en/stable/using.html

usage() {
    echo "Usage: $0 <test|production>" >&2
}

MODE=${1:-}
if [[ -z "${MODE}" ]]; then
    usage
    exit 1
fi

case "${MODE}" in
    test|staging)
        CERTBOT_MODE_LABEL="staging (test)"
        CERTBOT_SERVER_FLAG="--staging"
        ;;
    production|prod)
        CERTBOT_MODE_LABEL="production"
        CERTBOT_SERVER_FLAG=""
        ;;
    *)
        usage
        exit 1
        ;;
esac

# Locate environment files using the same logic as taskserver/env.mjs
node_env=${NODE_ENV:-development}
is_test_env=false
if [[ ${node_env} == "test" ]]; then
    is_test_env=true
fi

env_specific_file=".env.${node_env}"
env_specific_local_file="${env_specific_file}.local"

candidate_files=(
  ".env"
  "${env_specific_file}"
)
if [[ ${is_test_env} == false ]]; then
  candidate_files+=(".env.local")
fi
candidate_files+=("${env_specific_local_file}")

possible_names=("${env_specific_local_file}" "${env_specific_file}")
if [[ ${is_test_env} == false ]]; then
  possible_names+=(".env.local")
fi
possible_names+=(".env")

find_env_root() {
  local dir="$PWD"
  while true; do
    for name in "${possible_names[@]}"; do
      if [[ -n "$name" && -f "$dir/$name" ]]; then
        echo "$dir"
        return
      fi
    done
    local parent="$(dirname "$dir")"
    if [[ "$parent" == "$dir" ]]; then
      break
    fi
    dir="$parent"
  done
  echo "$PWD"
}

env_root="$(find_env_root)"
loaded_env_files=()

set -a
for file in "${candidate_files[@]}"; do
  [[ -n "$file" ]] || continue
  env_path="$env_root/$file"
  if [[ -f "$env_path" ]]; then
    echo "Loading environment variables from: $env_path"
    # shellcheck disable=SC1090
    source "$env_path"
    loaded_env_files+=("$env_path")
  fi
done
set +a

if [[ ${#loaded_env_files[@]} -eq 0 ]]; then
    echo "Error: No .env files found. Looked for ${candidate_files[*]} starting at $PWD." >&2
    exit 1
fi

compose_env_dir="${HOME}/.playday/env"
compose_env_file="${compose_env_dir}/letsencrypt-compose.env"
mkdir -p "${compose_env_dir}"

{
    echo '# Generated by init_letsencrypt.sh.'
    for source_env in "${loaded_env_files[@]}"; do
        [[ -f "${source_env}" ]] || continue
        echo "# Source: ${source_env}"
        sed -e 's/\r$//' -e 's/^export[[:space:]]\+//' "${source_env}"
        echo
    done
} > "${compose_env_file}"

export PLAYDAY_ENV_FILE="${compose_env_file}"

echo "Using docker compose env file: ${compose_env_file}"

if ! command -v docker-compose >/dev/null 2>&1 && ! (command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1); then
    echo 'Error: docker compose tooling is not installed or not accessible.' >&2
    exit 1
fi

if [[ -z "${NEXT_PUBLIC_BASE_URL:-}" ]]; then
    echo 'Error: NEXT_PUBLIC_BASE_URL is not set. Please update your .env file.' >&2
    exit 1
fi

if [[ "${NEXT_PUBLIC_BASE_URL}" == "localhost" ]]; then
    echo 'Error: NEXT_PUBLIC_BASE_URL cannot be localhost. Please update your .env file.' >&2
    exit 1
fi

if [[ -z "${SSL_CERT_EMAIL:-}" ]]; then
    echo 'Error: SSL_CERT_EMAIL is not set. Please update your .env file.' >&2
    exit 1
fi

resolve_ws_host() {
    for candidate in \
        "${NEXT_PUBLIC_WS_HOST:-}" \
        "${NEXT_PUBLIC_WS_BASE_URL:-}" \
        "${NEXT_PUBLIC_WS_NEXT_PUBLIC_BASE_URL:-}" \
        "${NEXT_PUBLIC_BASE_URL:-}"; do
        if [[ -n "${candidate// }" ]]; then
            printf '%s' "$candidate"
            return
        fi
    done
}

PRIMARY_DOMAIN="$(resolve_ws_host)"

if [[ -z "${PRIMARY_DOMAIN}" ]]; then
    echo 'Error: Unable to determine websocket hostname. Set NEXT_PUBLIC_WS_HOST or NEXT_PUBLIC_BASE_URL in your environment.' >&2
    exit 1
fi

DOMAINS=("${PRIMARY_DOMAIN}")

deduped=()
for domain in "${DOMAINS[@]}"; do
    [[ -z "${domain}" ]] && continue
    found=0
    for existing in "${deduped[@]}"; do
        if [[ "${existing}" == "${domain}" ]]; then
            found=1
            break
        fi
    done
    if (( found == 0 )); then
        deduped+=("${domain}")
    fi
done
DOMAINS=("${deduped[@]}")

cat <<INFO
Using Let's Encrypt ${CERTBOT_MODE_LABEL} environment
Domains to include: ${DOMAINS[*]}
INFO

cat <<'DNS'
Confirm DNS records are in place:
  - Each domain resolves to this server's public IP (A/AAAA record or CNAME).
  - Port 80 is reachable from the internet (required for the HTTP-01 challenge).
DNS

read -rp "Press Enter to continue once DNS is ready..."

docker_compose() {
    if command -v docker-compose >/dev/null 2>&1; then
        docker-compose "$@"
    else
        docker compose "$@"
    fi
}

data_path="${HOME}/.playday/ssldata/certbot"
email="${SSL_CERT_EMAIL}"
renew_script="${data_path}/renew.sh"
renew_log_dir="${data_path}/logs"
renew_log_file="${renew_log_dir}/renew.log"

cleanup_previous_state() {
    echo "### Resetting previous certbot/nginx state ..."
    docker_compose stop nginx certbot >/dev/null 2>&1 || true
    docker_compose rm -fsv nginx certbot >/dev/null 2>&1 || true
    rm -rf "${data_path:?}"
    rm -f "${renew_script}"
    rm -rf "${renew_log_dir}"
    mkdir -p "${data_path}"
}

existing_state=false
if [[ -d "${data_path}" ]]; then
    existing_state=true
fi
existing_services="$(docker_compose ps --services 2>/dev/null || true)"
if [[ "${existing_services}" == *certbot* || "${existing_services}" == *nginx* ]]; then
    existing_state=true
fi

if [[ "${existing_state}" == true ]]; then
    read -rp "Existing certificate data or containers detected. Reset before continuing? (Y/n) " decision
    decision=${decision:-Y}
    if [[ ! "${decision}" =~ ^[Yy]$ ]]; then
        echo "Aborting without modifying state."
        exit 0
    fi
    cleanup_previous_state
fi

if [[ ! -e "${data_path}/conf/options-ssl-nginx.conf" || ! -e "${data_path}/conf/ssl-dhparams.pem" ]]; then
    echo "### Downloading recommended TLS parameters ..."
    mkdir -p "${data_path}/conf"
    curl -fsSL https://raw.githubusercontent.com/certbot/certbot/master/certbot-nginx/certbot_nginx/_internal/tls_configs/options-ssl-nginx.conf > "${data_path}/conf/options-ssl-nginx.conf"
    curl -fsSL https://raw.githubusercontent.com/certbot/certbot/master/certbot/certbot/ssl-dhparams.pem > "${data_path}/conf/ssl-dhparams.pem"
    echo
fi

mkdir -p "${data_path}/conf/live/${PRIMARY_DOMAIN}"

echo "### Creating temporary self-signed certificate for nginx startup ..."
docker_compose run --rm --entrypoint "  openssl req -x509 -nodes -newkey rsa:2048 -days 1    -keyout '/etc/letsencrypt/live/${PRIMARY_DOMAIN}/privkey.pem'     -out '/etc/letsencrypt/live/${PRIMARY_DOMAIN}/fullchain.pem'     -subj '/CN=localhost'" certbot >/dev/null

echo "### Starting nginx container ..."
docker_compose up -d nginx

echo "### Removing temporary certificate files ..."
docker_compose run --rm --entrypoint "  rm -Rf /etc/letsencrypt/live/${PRIMARY_DOMAIN} &&   rm -Rf /etc/letsencrypt/archive/${PRIMARY_DOMAIN} &&   rm -Rf /etc/letsencrypt/renewal/${PRIMARY_DOMAIN}.conf" certbot >/dev/null

certbot_args=(
    certonly
    --webroot -w /var/www/certbot
    --non-interactive
    --agree-tos
    --keep-until-expiring
    --no-eff-email
    --key-type ecdsa
)

if [[ -n "${CERTBOT_SERVER_FLAG}" ]]; then
    certbot_args+=("${CERTBOT_SERVER_FLAG}")
fi

if [[ -n "${email}" ]]; then
    certbot_args+=(--email "${email}")
else
    certbot_args+=(--register-unsafely-without-email)
fi

for domain in "${DOMAINS[@]}"; do
    certbot_args+=(-d "${domain}")
done

echo "### Requesting ${CERTBOT_MODE_LABEL} certificate ..."
docker_compose run --rm --entrypoint certbot certbot "${certbot_args[@]}"

echo "### Reloading nginx to serve the new certificate ..."
docker_compose exec nginx nginx -s reload

echo "### Performing renewal dry run (recommended by Certbot documentation) ..."
docker_compose run --rm --entrypoint certbot certbot renew --dry-run

mkdir -p "${renew_log_dir}"

cat > "${renew_script}" <<RENEW
#!/bin/bash
set -euo pipefail

export PLAYDAY_ENV_FILE="${compose_env_file}"
cd "${script_dir}"

docker_compose_cmd() {
  if command -v docker-compose >/dev/null 2>&1; then
    docker-compose "\$@"
  else
    docker compose "\$@"
  fi
}

if docker_compose_cmd run --rm --entrypoint certbot certbot renew --quiet; then
  docker_compose_cmd exec nginx nginx -s reload >/dev/null 2>&1 || true
fi
RENEW
chmod +x "${renew_script}"

if command -v crontab >/dev/null 2>&1; then
    bash_path="$(command -v bash)"
    if [[ -n "${bash_path}" ]]; then
        cron_entry="0 */12 * * * ${bash_path} ${renew_script} >> ${renew_log_file} 2>&1"
        existing_crontab="$(crontab -l 2>/dev/null || true)"
        if [[ "${existing_crontab}" != *"${renew_script}"* ]]; then
            {
                if [[ -n "${existing_crontab}" ]]; then
                    printf '%s\n' "${existing_crontab}"
                fi
                printf '%s\n' "${cron_entry}"
            } | crontab -
            echo "Configured certbot renewal cron job (0 */12 * * *). Logs: ${renew_log_file}"
        else
            echo "Certbot renewal cron job already configured."
        fi
    else
        echo "Warning: Unable to locate 'bash'; skipping automatic renewal scheduling."
    fi
else
    echo "Warning: 'crontab' command not available; skipping automatic renewal scheduling."
fi


echo
echo "Recommended next steps:"
echo "  - Cron job installed (0 */12 * * *) to run ${renew_script}; review ${renew_log_file} for results."
echo "  - After manual renewals, run 'docker compose exec nginx nginx -s reload' if nginx has not reloaded automatically."
echo "  - Monitor ${data_path}/logs/ for renewal activity."
echo

echo "Certificate provisioning complete."
if [[ "${MODE}" =~ ^prod ]]; then
    echo "Production certificates are now installed for: ${DOMAINS[*]}"
else
    echo "Staging certificates were issued. Run the script again with 'production' before going live."
fi

